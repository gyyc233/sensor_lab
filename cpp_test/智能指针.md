
# RAII 资源创建即初始化

简单初步自定义智能指针

```cpp
#include <iostream>

template<typename T>
class SmartPtr{
public:
  SmartPtr(T *ptr=nullptr):m_ptr(ptr){
    std::cout<<"SmartPtr construction"<<std::endl;
  }
  ~SmartPtr(){
    std::cout<<"SmartPtr destruction"<<std::endl;
    delete m_ptr;
    }

private:
  T *m_ptr;
};
```

1. 构造函数中初始化资源地址，在析构函数中负责释放资源
2. 利用栈上的对象出作用域自动析构这个特点，在智能指针的析构函数中保证释放资源

所以，智能指针一般都定义在栈上，曾经有一个面试问题，问“能不能在堆上定义智能指针？”，如这段代码：

```
CSmartPtr *p = new CSmartPtr(new int);
```

这里定义的p虽然是智能指针类型，但它实质上还是一个裸指针，因此p还是需要进行手动delete，又回到了最开始裸指针我们面临的问题

在实现一个智能指针的时候，要让智能指针做到和裸指针相似，还得提供裸指针常见的*和->两种运算符的重载函数，这样，智能指针使用起来才真正的和裸指针一样

```cpp
template<typename T>
class SmartPtr{
public:
  SmartPtr(T *ptr=nullptr):m_ptr(ptr){
    std::cout<<"SmartPtr construction"<<std::endl;
  }
  ~SmartPtr(){
    std::cout<<"SmartPtr destruction"<<std::endl;
    delete m_ptr;
    }

  // rewrite * and -> operator

  // 取地址
  T &operator*(){
    return *m_ptr;
  }

  T *operator->(){
    return m_ptr;
  }

public:
  T *m_ptr;
};
```

上面的这个智能指针，使用起来就和普通的裸指针非常相似了，但是它还存在很大的问题
```cpp
  // pointer copy
  SmartPtr<int> ptr1(new int);
  SmartPtr<int> ptr2(ptr1);
```

这个main函数运行，代码直接崩溃，问题出在默认的拷贝构造函数做的是浅拷贝，两个智能指针都持有一个new int资源，ptr2先析构释放了资源，到ptr1析构的时候，就成了delete野指针了，造成程序崩溃。所以这里引出来智能指针需要解决的两件事情：

1. 怎么解决智能指针浅拷贝
2. 多个智能指针指向同一个资源时，怎么保证资源只释放一次，而不是每个智能指针都释放一次
