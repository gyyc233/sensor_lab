
# 左值右值 基于 C++11

左值是在内存的表达式，能够用内置的&进行取地址，其它可以算右值，右值更多的是一种“值”的表达，其中广义上右值又包含了纯右值与亡值，亡值一般就是我们说的生命周期即将结束的表达式

一些左值
```

1.字符串字面量，如："Hello"
2.内置的前++与前--，如：++a
3.变量类型是右值引用的表达式，如：TestClassA&& ra = TestClassA(1000);,ra这里是左值
4.转型为左值引用的表达式，如：static_cast<double&>(fValue);
5.内置*解引用的表达式，如：*pkValue
```

一些右值

```
1.非字符串的字面量以及枚举项，如：nullptr,true
2.内置的后++与后--，如：a--
3.内置的算术，逻辑，比较表达式，如：a+b，a&b，a||b, a<b
4.内置取地址表达式，this指针，如:&a
5.lamda表达式,如：[](int a){ return 2*a; }
6.转型为非引用的表达式，如：static_cast<double>(fValue), (float)42
7.转型为右值引用的表达式，如：static_cast<double&&>(fValue)，std::move(x);
```

# 左值引用和右值引用

- 指向左值的引用就是左引用，我们单个&来表示，C++11前一直使用的;
- 对右值的引用是右引用，我们用&&来表示

假设我们有如下代码
```cpp
class TestClassA {
    int m_iSize;
    char* m_pkData;
};

// 注意要求传入的rValue是右值，函数体内右值引用实际是左值
// 所以能对rValue取地址
TestClassA* operator& (TestClassA&& rValue) 
{
    return &rValue;
}

// 本来TestClassA()生成临时变量，是右值，但被“&”操作了。
// 这里我们手动重载了&，所以标准说法是不能用内置&取地址
TestClassA* pkA = &TestClassA(100);
```

```cpp
int a1 = 100;

// c1对左值a1引用，左引用
int& c1 = a1;

// b1对右值200的引用，右引用
int&& b1 = 200;

// rkTA1对右值TestClassA(1000)进行右引用
TestClassA&& rkTA1 = TestClassA(1000);

// 无法对右值( a1++)进行左引用，编译失败
int& c2 = a1++; // error

// 无法对左值a1进行直接右引用，编译失败
int&& b2 = a1; // error

// 无法对右值TestClassA(1000)进行左引用，编译失败
TestClassA& rkTA2 = TestClassA(1000); // error
```

我们可以看到，正常情况下左右引用只能处理对应的左右值，不能随意配对，否则编译失败

## 特别的const T&

const T&，常量左引用，能接受右值，直接对右值进行左引用，其生命周期被延续

```cpp
// 对右值101的常量左引用
const int& a2 = 101;
// 对右值TestClassA(1000)进行常量左引用
const TestClassA& rkTA2 = TestClassA(1000);
```

常用的拷贝构造函数T(const T&)参数是这个形式，vector容器的函数push_back(const value_type& val)参数也是，有没有注意到，这类函数同时也是接受右值的

```cpp

```

## 参考文章

- [左值右值](https://zh.cppreference.com/w/cpp/language/value_category)
- [谈谈C++的左值右值，左右引用，移动语意及完美转发](https://zhuanlan.zhihu.com/p/402251966)
